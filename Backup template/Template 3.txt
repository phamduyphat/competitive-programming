        "#include <bits/stdc++.h>",
        "#include <chrono>",
        "#define sexually_transferred_diseases std\t\t\t\t//Why not",
        "using namespace sexually_transferred_diseases;\t\t\t//UwU",
        "/*",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⣒⠯⣙⡟⠶⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⣥⠳⣘⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⢤⢶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡚⣤⢓⡹⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠴⡺⢍⡲⣉⢾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣧⢋⡵⢢⢤⡀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣦⣯⣔⣳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⡞⢭⣊⠵⢣⡽⢚⡿⢌⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⢱⠢⢷⣩⢒⣍⠲⣩⠛⣶⣤⡀⠀⠀⠀⠀⠀⠙⢿⣻⣟⡿⣷⣤⣀⡤⢤⠤⡴⣒⢖⡲⣒⠶⠤⣤⣠⣴⣿⢿⣧⡙⡲⣬⣾⡏⠀⣼⠲⣩⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠈⢣⠀⠈⠙⠮⢧⡥⢛⢼⣟⡿⣷⣤⡀⠀⣀⡤⠤⢴⡛⢭⢣⢍⠳⡌⣇⢣⡓⣜⢢⡕⢮⣾⣿⢿⣟⣯⡿⣯⣿⣮⢿⡝⡾⠀⠸⣥⣳⢡⣟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠘⡆⠀⢰⡦⣄⣹⠿⣿⣯⢿⣯⡿⢫⠝⣢⡵⣋⢦⡙⢦⢋⡬⢓⡱⣊⠵⣘⠦⣃⠞⣔⠪⡝⠿⢾⣻⣽⣷⢿⡹⣎⢷⡃⠀⠀⠀⠈⢉⣻⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣷⠀⢸⡥⢛⡛⢶⡛⡟⢾⠛⡷⣚⠶⣋⢧⡹⣌⠳⣌⠞⣡⠞⡥⢛⡔⢫⡔⢫⠴⡙⣆⠳⡔⡪⢭⡙⢏⡞⣧⡻⣬⡇⠀⠀⠠⢴⣚⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣿⡄⠀⢯⢣⡙⢦⡱⢎⢣⢫⢔⣣⡾⠳⣍⠳⣌⠳⣌⠞⣡⠞⣡⠏⡜⡥⡚⢥⢫⠜⡆⢏⡶⡙⢦⡙⢎⡴⡡⠿⣧⡇⠀⠀⠀⠀⠙⠾⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⡧⢷⠀⠘⣧⣙⠦⡱⢎⣣⢣⡾⡳⠚⡗⣌⠳⣌⠳⡌⢞⡡⢞⡡⢞⣱⡸⢥⢋⢦⠛⣌⠧⡗⡭⠎⣊⠇⠶⣙⢬⣹⣷⣄⠀⠀⠀⢀⣴⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⢀⡠⠤⠛⠉⠀⠀⠈⢻⣿⣟⣿⣿⣿⠣⣕⠪⣍⣧⣿⡌⢧⣹⣎⡜⢦⠹⣌⢦⡑⢎⡚⡴⢋⢦⣿⢗⡡⢏⢦⡙⣎⡱⠲⣼⣟⣿⣦⣀⣶⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠙⠒⠤⢤⣀⠀⠀⠀⣸⡝⣿⣿⣳⡏⣵⣮⢿⣟⣯⣟⣯⠆⣿⣯⡜⡬⢓⡜⣢⠝⣌⠳⢬⣹⣾⣿⣷⣍⢎⡲⢱⡸⣔⣿⣽⣻⣾⣻⣿⣿⡷⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⢸⣿⢿⠀⢰⣏⣾⣿⢯⡿⣟⣷⢿⣯⡿⣽⣾⣻⣿⡿⣽⣿⣴⣋⡴⢃⣞⣬⣷⡿⣿⠋⢳⣯⡿⣟⣿⣟⣿⣻⣽⡾⣯⣷⢿⡾⣽⡿⣿⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠐⣿⣿⢀⣷⣿⢿⡽⣟⣿⣻⣽⢿⣞⣿⢯⣷⣿⡿⣽⣟⣾⣽⢿⣻⣿⣻⣟⣾⠟⠁⢠⠄⢻⣿⣻⢷⣻⣽⣯⣷⣿⣻⢾⣟⣿⣽⣻⣽⣿⠿⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⢹⣿⣺⣿⢯⣿⣻⢿⣽⣻⣾⡿⠿⠚⠉⣴⣿⣟⣿⠞⣹⣿⣻⢯⣷⢿⡽⠋⢀⠌⠁⠈⠄⢿⣿⣻⣯⣷⣿⢏⣹⣿⡿⣿⣟⡿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⢛⣿⣯⣿⣷⠿⠿⠿⣿⢷⠚⠛⣿⣿⣿⣿⣾⣷⡄⣾⣿⣽⣿⣿⠿⢶⣿⣷⣶⣶⣶⣴⣬⣿⣷⣟⣾⢏⢦⣹⣷⡟⣛⢻⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⣼⡿⠊⣹⠴⡩⣍⡓⢾⢹⣷⣶⣿⣿⣿⣿⣿⣿⢣⣿⣯⣿⠟⢸⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢯⡟⡬⠲⣼⡷⡘⢦⢓⡚⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠋⣠⢚⣼⣷⡱⢆⡹⢺⠈⢿⣿⣿⣿⣿⣿⣿⠏⣸⣿⠟⠁⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⡿⣻⣿⡟⡜⢲⡙⣼⢲⡙⢆⡫⢜⠲⣌⣫⠟⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⢀⢴⡛⢬⠲⡌⢿⣿⣮⣕⣫⡆⠈⠛⠻⠿⠛⠛⠁⠀⠛⠁⠀⠀⠀⠀⠈⠛⠿⣿⣿⡿⢿⢫⡗⡥⡿⠜⣜⢣⣱⡟⢦⡙⣬⣱⣮⠗⠋⠄⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠛⠲⠛⠦⠯⣼⣉⢿⣟⣿⣻⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⢧⢱⠩⢞⣰⣷⡟⡱⡗⠛⠋⠁⠀⠀⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠰⠠⢀⠀⢢⡇⡎⣽⣿⡽⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠄⠀⠀⠀⠀⠀⢀⠈⠠⣿⣷⡿⣿⢿⣿⢏⠼⣡⢻⡀⠀⢄⠀⠀⠀⠀⡁⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⣠⠈⠐⠈⣷⣱⣏⠿⣷⣿⡆⠀⠀⠀⠀⠀⠀⠂⠐⠀⠒⠈⠀⠀⠀⠀⠀⠠⠊⢀⢰⣿⣯⡷⣟⣾⠋⠺⣴⣩⢚⡇⠂⢈⠀⠀⠀⠀⢡⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⢀⠀⠀⠀⠘⣄⠀⠀⠈⢱⣎⢳⡹⢿⣿⡷⢤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⣀⣿⣿⣳⡿⠫⢎⡀⠀⠀⠙⠮⡟⠀⢈⠀⠠⢀⠂⠄⣸⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀",
        "⠀⢸⠁⢄⠀⠀⠘⢆⠀⠂⠈⣎⢧⡙⢾⡛⠛⠉⢀⢩⠒⠦⠤⣤⣀⣀⣀⣀⣀⣮⢤⣾⠖⡛⢩⣿⠗⡋⠤⠂⠂⣈⠽⠀⠀⠀⠀⢀⠀⣀⡴⣇⠰⣆⠇⠀⠀⢀⠎⢸⠀⠀⠀⠀⠀",
        "⠀⠈⡆⡀⠑⠠⡀⠈⠳⣄⠀⠘⡶⣙⢦⡛⢶⢄⡀⠀⠀⡩⠁⠸⣷⣤⣄⣀⣤⣶⠾⡉⢠⠤⠟⠁⠀⣠⠴⣮⡁⠀⠀⠀⠀⠐⢈⣠⠼⣱⠳⣜⢫⠎⠀⢀⠔⠁⠀⠘⡀⠀⠀⠀⠀",
        "⠀⠀⢡⠀⠀⠀⠈⡑⠤⢀⣉⡒⠽⠼⣦⠝⣑⡐⡟⠀⢈⡉⠀⢇⢼⣿⣿⣿⣿⡿⠀⠐⠆⠀⡀⠀⠈⡆⡄⢀⠛⢓⣤⡦⢵⠺⣍⢎⡳⢥⡛⣬⠋⡠⠖⠑⠀⠀⠀⢠⠁⠀⠀⠀⠀",
        "⠀⠀⠀⢇⠂⠀⠀⠐⠀⠀⠀⢀⡴⢋⡠⡑⠄⢊⢗⠊⣥⣧⣴⠶⣾⣟⣿⣻⢿⣧⡒⡄⡜⢥⡉⣗⠲⣼⠜⠁⢀⠎⠸⣝⡻⣵⡎⢮⣱⡧⣛⠕⠈⠀⠀⠘⠀⠀⡠⢺⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠈⢦⡙⡖⣦⢤⣤⠞⣉⠔⣢⠱⣉⢎⢂⠁⣷⡘⡗⢩⢉⢸⣿⣾⣯⣿⣿⠘⡊⠍⠦⢱⣸⣗⢀⢰⠐⡡⢊⡀⠈⡑⢧⣛⢯⣐⠈⠀⠀⠀⠠⠐⠈⣨⠞⡧⡚⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠉⠚⣶⡋⢄⠲⣡⠚⡤⢓⡌⣎⣞⣳⡼⣩⡗⠢⠌⣻⣿⣳⢿⣽⣻⠀⠁⢀⠂⠄⣗⢮⡟⡥⡘⣌⢣⡙⢆⠠⢀⠙⢮⡝⣳⢦⣄⠀⢀⣤⠻⣥⠻⡱⠁⠀⠀⠀⠀⠀",
        "⢰⠄⡀⠀⠀⠀⡊⠁⠙⢮⡓⢤⢋⡔⣣⢞⡵⣮⢟⣲⡵⣁⣉⢉⣿⣿⣻⣿⣻⣿⡁⠔⠁⡈⢰⣏⢾⡯⣝⣧⡘⢆⡱⢊⡍⢦⡐⢀⠘⢣⡏⣾⢳⣻⣬⠳⠊⠔⠀⠀⢀⠀⠤⠐⠰",
        "⠈⡆⠀⠁⠂⢸⠙⣤⠁⠠⠙⢮⣲⣜⢷⣫⢾⡙⣮⠏⣔⣶⣾⣴⣿⣿⣿⡾⣿⣿⡈⠉⠉⠉⢉⣉⣉⡷⣩⢏⣷⡊⡔⢣⠜⣢⢑⠣⢆⣠⠞⢫⡳⣜⣺⠒⠄⠀⠀⠉⠀⠀⠀⢀⠆",
        "⠀⢡⠀⡀⠀⠀⠣⣈⠲⣁⠰⣜⡳⣯⡾⢣⢇⣿⢏⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣴⣭⣵⣭⣹⣏⡞⣧⣓⢎⡖⣻⣌⢣⠚⡤⢋⡼⠚⠁⡀⠂⢙⡼⠁⢀⠀⢀⠃⠀⠀⠀⠀⡌⠀",
        "⠀⠀⢃⠀⣄⠀⠀⠠⠑⠚⠛⣶⡹⢯⡱⣋⢾⣿⣞⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡹⣝⣷⠮⣜⡱⢻⣆⡹⣰⠏⡰⢶⠁⢠⡵⠫⠁⢀⠌⡠⠁⠀⠀⠀⠀⡜⠀⠀",
        "⠀⠀⠈⠣⣀⠊⢄⣀⡬⣟⡹⢆⣛⢦⣳⣿⣿⣷⣯⣭⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢻⡜⡾⣿⡰⣍⠳⣎⠿⣅⡸⠟⢀⡴⠯⠴⠤⠔⠁⠀⠀⠁⡘⠀⢐⠜⠀⠀⠀",
        "⠀⠀⠀⠀⠈⠑⠪⠌⣒⠣⢝⣾⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠹⣿⣿⣿⣿⢿⠿⣏⣷⣹⣳⠽⡗⣎⢳⢬⠳⣭⡝⠛⠋⠀⠀⠀⠀⠀⠀⠠⣐⢤⠔⡤⠊⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠋⣤⣾⣿⣿⣿⣟⢿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⢿⣿⣿⣿⣾⣶⣿⠿⡻⣿⣶⣣⡝⢮⡜⢦⣍⢳⡒⠶⡒⠖⣀⣀⡤⢖⣲⠫⢊⠔⠁⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣝⣿⣟⣿⣿⣧⣙⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⡟⣡⣷⣿⠿⣷⣿⣿⣦⡝⡲⢬⢣⡝⣣⢝⡹⢆⡳⡼⢓⡨⠒⠁⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⢹⣾⡏⢭⡙⢿⣿⣿⣮⢟⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣏⣼⣿⣿⣧⣇⣿⣿⣿⣹⣿⣟⠺⠥⣎⣑⣈⣣⠭⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣷⣢⣞⢯⣿⣿⣟⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣳⡟⢦⡹⢯⡘⢼⣫⡝⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠻⠿⠟⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣇⠣⡜⢢⢷⡹⣎⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⡒⡍⢆⣯⢳⣭⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⠿⣿⣷⣮⣾⠿⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "*/",
        "//array <class T, size_t N> arr;",
        "//vector <class T, class Alloc = allocator<T>> vector;",
        "//deque <class T, class Alloc = allocator<T> > deque;",
        "//priority_queue <class T, class Container = vector<T>,class Compare = less<typename Container::value_type>> priority_queue;",
        "//queue <class T, class Container = deque<T>> queue;",
        "//map <class Key, class T, class Compare = less<Key>, class Alloc = allocator<pair<const Key,T>>> map;",
        "#define FOR(i,a,b)      \tfor(int64_t i=a;i<=b;i++)",
        "#define fr(i,n)         \tfor(int64_t i=0;i<n;i++)",
        "#define fr1(i,n)        \tfor(int64_t i=1;i<=n;i++)",
        "#define FORI(i,a,b)      \tfor(int32_t i=a;i<=b;i++)",
        "#define fri(i,n)         \tfor(int32_t i=0;i<n;i++)",
        "#define fr1i(i,n)        \tfor(int32_t i=1;i<=n;i++)",
        "#define FORD(i, a, b)  \t\tfor(int64_t i=a;i>=b;i--)",
        "#define FORDI(i, a, b)\t\tfor(int32_t i=a;i>=b;i--)",
        "#define forv(a, b)\t\t\tfor(auto &a : b)",
        "#define sortall(arr)   \t \tsort(arr.begin(), arr.end())",
        "#define sortallmax(arr)\t \tsort(arr.begin(), arr.end(), greater<int64_t>())",
        "#define elif\t\t\t\telse if",
        "#define pb\t\t\t\t\tpush_back",
        "#define pf\t\t\t\t\tpush_front",
        "#define mp\t\t\t\t\tmake_pair",
        "#define fi\t\t\t\t\tfirst",
        "#define se\t\t\t\t\tsecond",
        "#define th\t\t\t\t\tthird",
        "#define str\t\t\t\t\tstring",
        "#define int\t\t\t\t\tlong long ",
        "#define endline\t\t\t\t\"\\n\"",
        "#define spaceuk\t\t\t\t\" \"",
        "#define driver\t\t\t\tint32_t",
        "#define vi\t\t\t\t\tvector<int32_t>",
        "#define qi\t\t\t\t\tqueue<int32_t>",
        "#define reset(a,b)\t\t\tmemset(a,b,sizeof(a))",
        "#define TOINFINITYANDBEYOND\t0x3f3f3f3f",
        "#define PI\t\t\t\t\t3.1415926535897932384626433832795",
        "const long long MODULO =\t1e9+7;",
        "const double pi =\t\t\tacos(-1.0);",
        "auto start =\t\t\t\tchrono::steady_clock::now();",
        "void finish(){",
        "\tauto end = chrono::steady_clock::now();",
        "\t//cout << \"Code run time: \";",
        "\tcout << chrono::duration<double, std::milli>(end - start).count() << \"ms\" << endl;",
        "\tfclose(stdin);",
        "\tfclose(stdout);",
        "\treturn;",
        "}",
        "#define ultimate_matrix",
        "/************************* Matrix **************************/",
        "// FOR NORMAL PEOPLE:",
        "#ifndef ultimate_matrix",
        "const int64_t length = 2;",
        "struct matrix{",
        "\tint64_t m[length][length];",
        "};",
        "matrix operator *(matrix a, matrix b)",
        "{",
        "\tmatrix c;",
        "\tfr(i,length) fr(j,length){",
        "\t\tc.m[i][j] = 0;",
        "\t\tfr(t,length) c.m[i][j] = (c.m[i][j] + (a.m[i][t] * b.m[t][j]) % MODULO) % MODULO;",
        "\t}",
        "\treturn c;",
        "}",
        "matrix operator ^(matrix a, int64_t n)",
        "{",
        "\tif (n == 1) return a;",
        "\tmatrix temp = a ^ (n / 2);",
        "\ttemp = temp * temp;",
        "\tif (n % 2 == 0) return temp;",
        "\telse return (temp * a);",
        "}",
        "/***********************************************************/",
        "#else",
        "/******************** ULTIMATE Matrix **********************/",
        "template<int32_t _MODULO> struct Modular{",
        "\tint64_t v;",
        "\texplicit operator int32_t() const {return v;} //explicitly -> don't silently convert to int32_t",
        "\tModular() {v = 0;}",
        "\tModular(int64_t _v) ",
        "\t{",
        "\t\tv = int32_t((-_MODULO < _v && _v < _MODULO) ? _v : _v % _MODULO); ",
        "\t\tif (v < 0) v += _MODULO;",
        "\t}",
        "\tfriend ostream& operator << (ostream& out, const Modular &n)",
        "\t{",
        "\t\treturn out << int32_t(n);",
        "\t}",
        "\tfriend istream& operator >> (istream& in, const Modular &n)",
        "\t{",
        "\t\tint64_t _v;",
        "\t\tin >> _v;",
        "\t\tn = Modular(_v);",
        "\t\treturn in;",
        "\t}",
        "",
        "\tfriend bool operator == (const Modular &a, const Modular &b) {return a.v == b.v;}",
        "\tfriend bool operator != (const Modular &a, const Modular &b) {return a.v != b.v;}",
        "\tfriend bool operator < (const Modular &a, const Modular &b) {return a.v < b.v;}",
        "\tfriend bool operator > (const Modular &a, const Modular &b) {return a.v > b.v;}",
        "\t",
        "\tModular& operator += (const Modular &m)",
        "\t{",
        "\t\tif ((v += m.v) > _MODULO)",
        "\t\t\tv -= _MODULO;",
        "\t\treturn *this;",
        "\t}",
        "\tModular& operator -= (const Modular &m)",
        "\t{",
        "\t\tif ((v -= m.v) < 0)",
        "\t\t\tv += _MODULO;",
        "\t\treturn *this;",
        "\t}",
        "\tModular& operator *= (const Modular &m)",
        "\t{",
        "\t\tv = int32_t((int64_t) v * m.v % _MODULO);",
        "\t\treturn *this;",
        "\t}",
        "\tModular& operator /= (const Modular &m)",
        "\t{",
        "\t\treturn (*this) *= inv(m);",
        "\t}",
        "\tModular operator - () const {return Modular(-v);}",
        "",
        "\tModular &operator ++() {return *this += 1;}",
        "\tModular &operator --() {return *this -= 1;}",
        "\tfriend Modular pow(Modular a, int64_t p)",
        "\t{",
        "\t\tModular ans = 1;",
        "\t\tassert(p >= 0);",
        "\t\tfor(; p; p /= 2, a *= a)",
        "\t\t\tif (p & 1)",
        "\t\t\t\tans *= a;",
        "\t\treturn ans;",
        "\t}",
        "\tfriend Modular inv(const Modular &a)",
        "\t{",
        "\t\tassert(a.v != 0);",
        "\t\treturn pow(a, _MODULO - 2);",
        "\t}",
        "\tfriend Modular operator + (Modular a, const Modular &b) {return a += b;}",
        "\tfriend Modular operator - (Modular a, const Modular &b) {return a -= b;}",
        "\tfriend Modular operator * (Modular a, const Modular &b) {return a *= b;}",
        "\tfriend Modular operator / (Modular a, const Modular &b) {return a /= b;}",
        "\tfriend Modular operator ++ (Modular &a, int32_t)",
        "\t{",
        "\t\tModular r = a;",
        "\t\t++ a;",
        "\t\treturn r;",
        "\t}",
        "\tfriend Modular operator -- (Modular &a, int32_t)",
        "\t{",
        "\t\tModular r = a;",
        "\t\t-- a;",
        "\t\treturn r;",
        "\t}",
        "};",
        "",
        "template <class T> struct matrix{",
        "\tvector<vector<T>> m;",
        "\tint64_t r, c;",
        "\tmatrix() : r(), c() {}",
        "\tmatrix(int64_t r, int64_t c, T x) : r(r), c(c), m(r, vector<T> (c, x)) {}",
        "\tmatrix(int64_t n) : matrix (n, n, 0) \t//identity matrix",
        "\t{",
        "\t\tfor(int64_t i = 0; i < n; i ++)",
        "\t\t\tm[i][i] = 1;",
        "\t}",
        "\tmatrix operator * (matrix<T> b)",
        "\t{",
        "\t\tmatrix<T> a = *this;",
        "\t\tassert(a.c == b.r);",
        "\t\tmatrix<T> c(a.r, b.c, 0);",
        "\t\t{",
        "\t\t\tfor(int64_t i = 0; i < a.r; i ++)",
        "\t\t\t\tfor(int64_t j = 0; j < b.c; j ++)",
        "\t\t\t\t\tfor(int64_t k = 0; k < a.c; k ++)",
        "\t\t\t\t\t\tc.m[i][j] = c.m[i][j] + a.m[i][k] * b.m[k][j];",
        "\t\t}",
        "\t\treturn c;",
        "\t}",
        "\tmatrix operator ^ (int64_t b)",
        "\t{",
        "\t\tmatrix<T> a = *this;",
        "\t\tassert(a.r == a.c);",
        "\t\tmatrix<T> o(a.r);",
        "\t\twhile(b)",
        "\t\t{",
        "\t\t\tif (b % 2)",
        "\t\t\t\to = o * a;",
        "\t\t\ta = a * a;",
        "\t\t\tb /= 2;",
        "\t\t}",
        "\t\treturn o;",
        "\t}",
        "\tvoid print()",
        "\t{",
        "\t\tfor(int64_t i = 0; i < r; i ++)",
        "\t\t{",
        "\t\t\tfor(int64_t j = 0; j < c; j ++)",
        "\t\t\t\tcout << m[i][j] << spaceuk;",
        "\t\t\tcout << endline;",
        "\t\t}",
        "",
        "\t}",
        "};",
        "",
        "using mint = Modular<MODULO>;",
        "#endif",
        "/***********************************************************/",
        "#define BIGINT",
        "/********************** THE BIG INT ************************/",
        "#ifdef BIGINT",
        "const int32_t base = 1000000000;",
        "const int32_t base_digits = 9; ",
        "struct int128_t {",
        "\tvector<int32_t> a;",
        "\tint32_t sign;",
        "\t",
        "\tint32_t size(){",
        "\t\tif(a.empty())return 0;",
        "\t\tint32_t ans=(a.size()-1)*base_digits;",
        "\t\tint32_t ca=a.back();",
        "\t\twhile(ca)",
        "\t\t\tans++,ca/=10;",
        "\t\treturn ans;",
        "\t}",
        "\tint128_t operator ^(const int128_t &v){",
        "\t\tint128_t ans=1,a=*this,b=v;",
        "\t\twhile(!b.isZero()){",
        "\t\t\tif(b%2)",
        "\t\t\t\tans*=a;",
        "\t\t\ta*=a,b/=2;",
        "\t\t}",
        "\t\treturn ans;",
        "\t}",
        "\tstring to_string(){",
        "\t\tstringstream ss;",
        "\t\tss << *this;",
        "\t\tstring s;",
        "\t\tss >> s;",
        "\t\treturn s;",
        "\t}",
        "\tint32_t sumof(){",
        "\t\tstring s = to_string();",
        "\t\tint32_t ans = 0;",
        "\t\tfor(auto c : s)  ans += c - '0';",
        "\t\treturn ans;",
        "\t}",
        "\t",
        "\tint128_t() :",
        "\t\tsign(1) {",
        "\t}",
        " ",
        "\tint128_t(int64_t v) {",
        "\t\t*this = v;",
        "\t}",
        " ",
        "\tint128_t(const string &s) {",
        "\t\tread(s);",
        "\t}",
        " ",
        "\tvoid operator=(const int128_t &v) {",
        "\t\tsign = v.sign;",
        "\t\ta = v.a;",
        "\t}",
        " ",
        "\tvoid operator=(int64_t v) {",
        "\t\tsign = 1;",
        "\t\ta.clear();",
        "\t\tif (v < 0)",
        "\t\t\tsign = -1, v = -v;",
        "\t\tfor (; v > 0; v = v / base)",
        "\t\t\ta.push_back(v % base);",
        "\t}",
        " ",
        "\tint128_t operator+(const int128_t &v) const {",
        "\t\tif (sign == v.sign) {",
        "\t\t\tint128_t res = v;",
        " ",
        "\t\t\tfor (int32_t i = 0, carry = 0; i < (int32_t) max(a.size(), v.a.size()) || carry; ++i) {",
        "\t\t\t\tif (i == (int32_t) res.a.size())",
        "\t\t\t\t\tres.a.push_back(0);",
        "\t\t\t\tres.a[i] += carry + (i < (int32_t) a.size() ? a[i] : 0);",
        "\t\t\t\tcarry = res.a[i] >= base;",
        "\t\t\t\tif (carry)",
        "\t\t\t\t\tres.a[i] -= base;",
        "\t\t\t}",
        "\t\t\treturn res;",
        "\t\t}",
        "\t\treturn *this - (-v);",
        "\t}",
        " ",
        "\tint128_t operator-(const int128_t &v) const {",
        "\t\tif (sign == v.sign) {",
        "\t\t\tif (abs() >= v.abs()) {",
        "\t\t\t\tint128_t res = *this;",
        "\t\t\t\tfor (int32_t i = 0, carry = 0; i < (int32_t) v.a.size() || carry; ++i) {",
        "\t\t\t\t\tres.a[i] -= carry + (i < (int32_t) v.a.size() ? v.a[i] : 0);",
        "\t\t\t\t\tcarry = res.a[i] < 0;",
        "\t\t\t\t\tif (carry)",
        "\t\t\t\t\t\tres.a[i] += base;",
        "\t\t\t\t}",
        "\t\t\t\tres.trim();",
        "\t\t\t\treturn res;",
        "\t\t\t}",
        "\t\t\treturn -(v - *this);",
        "\t\t}",
        "\t\treturn *this + (-v);",
        "\t}",
        " ",
        "\tvoid operator*=(int32_t v) {",
        "\t\tif (v < 0)",
        "\t\t\tsign = -sign, v = -v;",
        "\t\tfor (int32_t i = 0, carry = 0; i < (int32_t) a.size() || carry; ++i) {",
        "\t\t\tif (i == (int32_t) a.size())",
        "\t\t\t\ta.push_back(0);",
        "\t\t\tint64_t cur = a[i] * (int64_t) v + carry;",
        "\t\t\tcarry = (int32_t) (cur / base);",
        "\t\t\ta[i] = (int32_t) (cur % base);",
        "\t\t\t//asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
        "\t\t}",
        "\t\ttrim();",
        "\t}",
        " ",
        "\tint128_t operator*(int32_t v) const {",
        "\t\tint128_t res = *this;",
        "\t\tres *= v;",
        "\t\treturn res;",
        "\t}",
        " ",
        "\tvoid operator*=(int64_t v) {",
        "\t\tif (v < 0)",
        "\t\t\tsign = -sign, v = -v;",
        "\t\tif(v > base){",
        "\t\t\t*this = *this * (v / base) * base + *this * (v % base);",
        "\t\t\treturn ;",
        "\t\t}",
        "\t\tfor (int32_t i = 0, carry = 0; i < (int32_t) a.size() || carry; ++i) {",
        "\t\t\tif (i == (int32_t) a.size())",
        "\t\t\t\ta.push_back(0);",
        "\t\t\tint64_t cur = a[i] * (int64_t) v + carry;",
        "\t\t\tcarry = (int32_t) (cur / base);",
        "\t\t\ta[i] = (int32_t) (cur % base);",
        "\t\t\t//asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
        "\t\t}",
        "\t\ttrim();",
        "\t}",
        " ",
        "\tint128_t operator*(int64_t v) const {",
        "\t\tint128_t res = *this;",
        "\t\tres *= v;",
        "\t\treturn res;",
        "\t}",
        " ",
        "\tfriend pair<int128_t, int128_t> divmod(const int128_t &a1, const int128_t &b1) {",
        "\t\tint32_t norm = base / (b1.a.back() + 1);",
        "\t\tint128_t a = a1.abs() * norm;",
        "\t\tint128_t b = b1.abs() * norm;",
        "\t\tint128_t q, r;",
        "\t\tq.a.resize(a.a.size());",
        " ",
        "\t\tfor (int32_t i = a.a.size() - 1; i >= 0; i--) {",
        "\t\t\tr *= base;",
        "\t\t\tr += a.a[i];",
        "\t\t\tint32_t s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
        "\t\t\tint32_t s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
        "\t\t\tint32_t d = ((int64_t) base * s1 + s2) / b.a.back();",
        "\t\t\tr -= b * d;",
        "\t\t\twhile (r < 0)",
        "\t\t\t\tr += b, --d;",
        "\t\t\tq.a[i] = d;",
        "\t\t}",
        " ",
        "\t\tq.sign = a1.sign * b1.sign;",
        "\t\tr.sign = a1.sign;",
        "\t\tq.trim();",
        "\t\tr.trim();",
        "\t\treturn make_pair(q, r / norm);",
        "\t}",
        " ",
        "\tint128_t operator/(const int128_t &v) const {",
        "\t\treturn divmod(*this, v).first;",
        "\t}",
        " ",
        "\tint128_t operator%(const int128_t &v) const {",
        "\t\treturn divmod(*this, v).second;",
        "\t}",
        " ",
        "\tvoid operator/=(int32_t v) {",
        "\t\tif (v < 0)",
        "\t\t\tsign = -sign, v = -v;",
        "\t\tfor (int32_t i = (int32_t) a.size() - 1, rem = 0; i >= 0; --i) {",
        "\t\t\tint64_t cur = a[i] + rem * (int64_t) base;",
        "\t\t\ta[i] = (int32_t) (cur / v);",
        "\t\t\trem = (int32_t) (cur % v);",
        "\t\t}",
        "\t\ttrim();",
        "\t}",
        " ",
        "\tint128_t operator/(int32_t v) const {",
        "\t\tint128_t res = *this;",
        "\t\tres /= v;",
        "\t\treturn res;",
        "\t}",
        " ",
        "\tint32_t operator%(int32_t v) const {",
        "\t\tif (v < 0)",
        "\t\t\tv = -v;",
        "\t\tint32_t m = 0;",
        "\t\tfor (int32_t i = a.size() - 1; i >= 0; --i)",
        "\t\t\tm = (a[i] + m * (int64_t) base) % v;",
        "\t\treturn m * sign;",
        "\t}",
        " ",
        "\tvoid operator+=(const int128_t &v) {",
        "\t\t*this = *this + v;",
        "\t}",
        "\tvoid operator-=(const int128_t &v) {",
        "\t\t*this = *this - v;",
        "\t}",
        "\tvoid operator*=(const int128_t &v) {",
        "\t\t*this = *this * v;",
        "\t}",
        "\tvoid operator/=(const int128_t &v) {",
        "\t\t*this = *this / v;",
        "\t}",
        " ",
        "\tbool operator<(const int128_t &v) const {",
        "\t\tif (sign != v.sign)",
        "\t\t\treturn sign < v.sign;",
        "\t\tif (a.size() != v.a.size())",
        "\t\t\treturn a.size() * sign < v.a.size() * v.sign;",
        "\t\tfor (int32_t i = a.size() - 1; i >= 0; i--)",
        "\t\t\tif (a[i] != v.a[i])",
        "\t\t\t\treturn a[i] * sign < v.a[i] * sign;",
        "\t\treturn false;",
        "\t}",
        " ",
        "\tbool operator>(const int128_t &v) const {",
        "\t\treturn v < *this;",
        "\t}",
        "\tbool operator<=(const int128_t &v) const {",
        "\t\treturn !(v < *this);",
        "\t}",
        "\tbool operator>=(const int128_t &v) const {",
        "\t\treturn !(*this < v);",
        "\t}",
        "\tbool operator==(const int128_t &v) const {",
        "\t\treturn !(*this < v) && !(v < *this);",
        "\t}",
        "\tbool operator!=(const int128_t &v) const {",
        "\t\treturn *this < v || v < *this;",
        "\t}",
        " ",
        "\tvoid trim() {",
        "\t\twhile (!a.empty() && !a.back())",
        "\t\t\ta.pop_back();",
        "\t\tif (a.empty())",
        "\t\t\tsign = 1;",
        "\t}",
        " ",
        "\tbool isZero() const {",
        "\t\treturn a.empty() || (a.size() == 1 && !a[0]);",
        "\t}",
        " ",
        "\tint128_t operator-() const {",
        "\t\tint128_t res = *this;",
        "\t\tres.sign = -sign;",
        "\t\treturn res;",
        "\t}",
        " ",
        "\tint128_t abs() const {",
        "\t\tint128_t res = *this;",
        "\t\tres.sign *= res.sign;",
        "\t\treturn res;",
        "\t}",
        " ",
        "\tint64_t longValue() const {",
        "\t\tint64_t res = 0;",
        "\t\tfor (int32_t i = a.size() - 1; i >= 0; i--)",
        "\t\t\tres = res * base + a[i];",
        "\t\treturn res * sign;",
        "\t}",
        " ",
        "\tfriend int128_t gcd(const int128_t &a, const int128_t &b) {",
        "\t\treturn b.isZero() ? a : gcd(b, a % b);",
        "\t}",
        "\tfriend int128_t lcm(const int128_t &a, const int128_t &b) {",
        "\t\treturn a / gcd(a, b) * b;",
        "\t}",
        " ",
        "\tvoid read(const string &s) {",
        "\t\tsign = 1;",
        "\t\ta.clear();",
        "\t\tint32_t pos = 0;",
        "\t\twhile (pos < (int32_t) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
        "\t\t\tif (s[pos] == '-')",
        "\t\t\t\tsign = -sign;",
        "\t\t\t++pos;",
        "\t\t}",
        "\t\tfor (int32_t i = s.size() - 1; i >= pos; i -= base_digits) {",
        "\t\t\tint32_t x = 0;",
        "\t\t\tfor (int32_t j = max(pos, i - base_digits + 1); j <= i; j++)",
        "\t\t\t\tx = x * 10 + s[j] - '0';",
        "\t\t\ta.push_back(x);",
        "\t\t}",
        "\t\ttrim();",
        "\t}",
        " ",
        "\tfriend istream& operator>>(istream &stream, int128_t &v) {",
        "\t\tstring s;",
        "\t\tstream >> s;",
        "\t\tv.read(s);",
        "\t\treturn stream;",
        "\t}",
        " ",
        "\tfriend ostream& operator<<(ostream &stream, const int128_t &v) {",
        "\t\tif (v.sign == -1)",
        "\t\t\tstream << '-';",
        "\t\tstream << (v.a.empty() ? 0 : v.a.back());",
        "\t\tfor (int32_t i = (int32_t) v.a.size() - 2; i >= 0; --i)",
        "\t\t\tstream << setw(base_digits) << setfill('0') << v.a[i];",
        "\t\treturn stream;",
        "\t}",
        " ",
        "\tstatic vector<int32_t> convert_base(const vector<int32_t> &a, int32_t old_digits, int32_t new_digits) {",
        "\t\tvector<int64_t> p(max(old_digits, new_digits) + 1);",
        "\t\tp[0] = 1;",
        "\t\tfor (int32_t i = 1; i < (int32_t) p.size(); i++)",
        "\t\t\tp[i] = p[i - 1] * 10;",
        "\t\tvector<int32_t> res;",
        "\t\tint64_t cur = 0;",
        "\t\tint32_t cur_digits = 0;",
        "\t\tfor (int32_t i = 0; i < (int32_t) a.size(); i++) {",
        "\t\t\tcur += a[i] * p[cur_digits];",
        "\t\t\tcur_digits += old_digits;",
        "\t\t\twhile (cur_digits >= new_digits) {",
        "\t\t\t\tres.push_back(int32_t(cur % p[new_digits]));",
        "\t\t\t\tcur /= p[new_digits];",
        "\t\t\t\tcur_digits -= new_digits;",
        "\t\t\t}",
        "\t\t}",
        "\t\tres.push_back((int32_t) cur);",
        "\t\twhile (!res.empty() && !res.back())",
        "\t\t\tres.pop_back();",
        "\t\treturn res;",
        "\t}",
        " ",
        "\ttypedef vector<int64_t> vll;",
        " ",
        "\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {",
        "\t\tint32_t n = a.size();",
        "\t\tvll res(n + n);",
        "\t\tif (n <= 32) {",
        "\t\t\tfor (int32_t i = 0; i < n; i++)",
        "\t\t\t\tfor (int32_t j = 0; j < n; j++)",
        "\t\t\t\t\tres[i + j] += a[i] * b[j];",
        "\t\t\treturn res;",
        "\t\t}",
        " ",
        "\t\tint32_t k = n >> 1;",
        "\t\tvll a1(a.begin(), a.begin() + k);",
        "\t\tvll a2(a.begin() + k, a.end());",
        "\t\tvll b1(b.begin(), b.begin() + k);",
        "\t\tvll b2(b.begin() + k, b.end());",
        " ",
        "\t\tvll a1b1 = karatsubaMultiply(a1, b1);",
        "\t\tvll a2b2 = karatsubaMultiply(a2, b2);",
        " ",
        "\t\tfor (int32_t i = 0; i < k; i++)",
        "\t\t\ta2[i] += a1[i];",
        "\t\tfor (int32_t i = 0; i < k; i++)",
        "\t\t\tb2[i] += b1[i];",
        " ",
        "\t\tvll r = karatsubaMultiply(a2, b2);",
        "\t\tfor (int32_t i = 0; i < (int32_t) a1b1.size(); i++)",
        "\t\t\tr[i] -= a1b1[i];",
        "\t\tfor (int32_t i = 0; i < (int32_t) a2b2.size(); i++)",
        "\t\t\tr[i] -= a2b2[i];",
        " ",
        "\t\tfor (int32_t i = 0; i < (int32_t) r.size(); i++)",
        "\t\t\tres[i + k] += r[i];",
        "\t\tfor (int32_t i = 0; i < (int32_t) a1b1.size(); i++)",
        "\t\t\tres[i] += a1b1[i];",
        "\t\tfor (int32_t i = 0; i < (int32_t) a2b2.size(); i++)",
        "\t\t\tres[i + n] += a2b2[i];",
        "\t\treturn res;",
        "\t}",
        " ",
        "\tint128_t operator*(const int128_t &v) const {",
        "\t\tvector<int32_t> a6 = convert_base(this->a, base_digits, 6);",
        "\t\tvector<int32_t> b6 = convert_base(v.a, base_digits, 6);",
        "\t\tvll a(a6.begin(), a6.end());",
        "\t\tvll b(b6.begin(), b6.end());",
        "\t\twhile (a.size() < b.size())",
        "\t\t\ta.push_back(0);",
        "\t\twhile (b.size() < a.size())",
        "\t\t\tb.push_back(0);",
        "\t\twhile (a.size() & (a.size() - 1))",
        "\t\t\ta.push_back(0), b.push_back(0);",
        "\t\tvll c = karatsubaMultiply(a, b);",
        "\t\tint128_t res;",
        "\t\tres.sign = sign * v.sign;",
        "\t\tfor (int32_t i = 0, carry = 0; i < (int32_t) c.size(); i++) {",
        "\t\t\tint64_t cur = c[i] + carry;",
        "\t\t\tres.a.push_back((int32_t) (cur % 1000000));",
        "\t\t\tcarry = (int32_t) (cur / 1000000);",
        "\t\t}",
        "\t\tres.a = convert_base(res.a, 6, base_digits);",
        "\t\tres.trim();",
        "\t\treturn res;",
        "\t}",
        "};",
        "#endif",
        "/***********************************************************/",
        "//predefined functions:",
        "template<typename A, typename B, typename C>\tstruct threesome{",
        "\tA first;",
        "\tB second;",
        "\tC third;",
        "};",
        "int64_t getbit(int32_t i, int64_t x){return ((x >> i) & 1);}",
        "int64_t mul(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 0;",
        "\twhile (b > 0)",
        "\t{",
        "\t\tif (b % 2 == 1)",
        "\t\t\tres = (res + a);",
        "\t\ta = (a * 2);",
        "\t\tb /= 2;",
        "\t}",
        "\treturn res;",
        "}",
        "int64_t power(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 1;",
        "\ta %= b;",
        "\tif (a == 0) return 0;",
        "\twhile(b > 0)",
        "\t{",
        "\t\tif (b & 1)",
        "\t\t\tres = mul(res, a);",
        "\t\tb /= 2;",
        "\t\ta = mul(a, a);",
        "\t}",
        "\treturn res;",
        "}",
        "int64_t Modular_multiplication(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 0;",
        "\ta %= MODULO;",
        "\twhile (b > 0)",
        "\t{",
        "\t\tif (b % 2 == 1)",
        "\t\t\tres = (res + a) % MODULO;",
        "\t\ta = (a * 2) % MODULO;",
        "\t\tb /= 2;",
        "\t}",
        "\treturn res % MODULO;",
        "}",
        "int64_t Modular_exponentiation(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 1;",
        "\ta %= b;",
        "\tif (a == 0) return 0;",
        "\twhile(b > 0)",
        "\t{",
        "\t\tif (b & 1)",
        "\t\t\tres = Modular_multiplication(res, a);",
        "\t\tb /= 2;",
        "\t\ta = Modular_multiplication(a, a);",
        "\t}",
        "\treturn res;",
        "}",
        "/***********************************************************/",
        "//Global variables below this line:",
        "",
        "/***********************************************************/",
        "//Functions declarations:",
        "",
        "/***********************************************************/",
        "// #define task \"\"",
        "// #define standard_input ",
        "#define input_extension \".inp\"",
        "#define output_extension \".out\"",
        "driver main(){",
        "\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
        "#ifndef standard_input",
        "\t#ifdef task",
        "\t\tif (!fopen(task input_extension,\"r\"))",
        "\t\t\treturn -1;",
        "\t\tfreopen (task input_extension, \"r\", stdin);",
        "\t\tfreopen (task output_extension, \"w\", stdout);",
        "\t#else",
        "\t\tif (!fopen(\"input.inp\",\"r\"))",
        "\t\t{",
        "\t\t\tcerr << \"U STUPID\" << endline;",
        "\t\t\treturn -1;",
        "\t\t}",
        "\t\tfreopen (\"input.inp\",\"r\",stdin);",
        "\t\tfreopen (\"output.out\",\"w\",stdout);",
        "\t#endif",
        "#endif",
        "\t//code below this line:",
        "\t",
        "#ifndef standard_input",
        "\t#ifndef task",
        "\t\tfinish();",
        "\t#endif",
        "#endif",
        "\treturn 0;",
        "}",
        "//Functions content:",
        "\t"