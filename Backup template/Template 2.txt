        "#include <bits/stdc++.h>",
        "#include <chrono>",
        "#define sexually_transferred_diseases std\t\t\t\t//Why not",
        "using namespace sexually_transferred_diseases;\t\t\t//UwU",
        "/*",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⣒⠯⣙⡟⠶⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡞⣥⠳⣘⡞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⢤⢶⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡚⣤⢓⡹⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠴⡺⢍⡲⣉⢾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣧⢋⡵⢢⢤⡀⠀⠀⠀⠀⠀⠀⠀⠘⢷⣦⣯⣔⣳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⡞⢭⣊⠵⢣⡽⢚⡿⢌⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⢱⠢⢷⣩⢒⣍⠲⣩⠛⣶⣤⡀⠀⠀⠀⠀⠀⠙⢿⣻⣟⡿⣷⣤⣀⡤⢤⠤⡴⣒⢖⡲⣒⠶⠤⣤⣠⣴⣿⢿⣧⡙⡲⣬⣾⡏⠀⣼⠲⣩⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠈⢣⠀⠈⠙⠮⢧⡥⢛⢼⣟⡿⣷⣤⡀⠀⣀⡤⠤⢴⡛⢭⢣⢍⠳⡌⣇⢣⡓⣜⢢⡕⢮⣾⣿⢿⣟⣯⡿⣯⣿⣮⢿⡝⡾⠀⠸⣥⣳⢡⣟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠘⡆⠀⢰⡦⣄⣹⠿⣿⣯⢿⣯⡿⢫⠝⣢⡵⣋⢦⡙⢦⢋⡬⢓⡱⣊⠵⣘⠦⣃⠞⣔⠪⡝⠿⢾⣻⣽⣷⢿⡹⣎⢷⡃⠀⠀⠀⠈⢉⣻⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣷⠀⢸⡥⢛⡛⢶⡛⡟⢾⠛⡷⣚⠶⣋⢧⡹⣌⠳⣌⠞⣡⠞⡥⢛⡔⢫⡔⢫⠴⡙⣆⠳⡔⡪⢭⡙⢏⡞⣧⡻⣬⡇⠀⠀⠠⢴⣚⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⣿⡄⠀⢯⢣⡙⢦⡱⢎⢣⢫⢔⣣⡾⠳⣍⠳⣌⠳⣌⠞⣡⠞⣡⠏⡜⡥⡚⢥⢫⠜⡆⢏⡶⡙⢦⡙⢎⡴⡡⠿⣧⡇⠀⠀⠀⠀⠙⠾⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⡧⢷⠀⠘⣧⣙⠦⡱⢎⣣⢣⡾⡳⠚⡗⣌⠳⣌⠳⡌⢞⡡⢞⡡⢞⣱⡸⢥⢋⢦⠛⣌⠧⡗⡭⠎⣊⠇⠶⣙⢬⣹⣷⣄⠀⠀⠀⢀⣴⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⢀⡠⠤⠛⠉⠀⠀⠈⢻⣿⣟⣿⣿⣿⠣⣕⠪⣍⣧⣿⡌⢧⣹⣎⡜⢦⠹⣌⢦⡑⢎⡚⡴⢋⢦⣿⢗⡡⢏⢦⡙⣎⡱⠲⣼⣟⣿⣦⣀⣶⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠙⠒⠤⢤⣀⠀⠀⠀⣸⡝⣿⣿⣳⡏⣵⣮⢿⣟⣯⣟⣯⠆⣿⣯⡜⡬⢓⡜⣢⠝⣌⠳⢬⣹⣾⣿⣷⣍⢎⡲⢱⡸⣔⣿⣽⣻⣾⣻⣿⣿⡷⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⢸⣿⢿⠀⢰⣏⣾⣿⢯⡿⣟⣷⢿⣯⡿⣽⣾⣻⣿⡿⣽⣿⣴⣋⡴⢃⣞⣬⣷⡿⣿⠋⢳⣯⡿⣟⣿⣟⣿⣻⣽⡾⣯⣷⢿⡾⣽⡿⣿⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠐⣿⣿⢀⣷⣿⢿⡽⣟⣿⣻⣽⢿⣞⣿⢯⣷⣿⡿⣽⣟⣾⣽⢿⣻⣿⣻⣟⣾⠟⠁⢠⠄⢻⣿⣻⢷⣻⣽⣯⣷⣿⣻⢾⣟⣿⣽⣻⣽⣿⠿⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⢹⣿⣺⣿⢯⣿⣻⢿⣽⣻⣾⡿⠿⠚⠉⣴⣿⣟⣿⠞⣹⣿⣻⢯⣷⢿⡽⠋⢀⠌⠁⠈⠄⢿⣿⣻⣯⣷⣿⢏⣹⣿⡿⣿⣟⡿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⢛⣿⣯⣿⣷⠿⠿⠿⣿⢷⠚⠛⣿⣿⣿⣿⣾⣷⡄⣾⣿⣽⣿⣿⠿⢶⣿⣷⣶⣶⣶⣴⣬⣿⣷⣟⣾⢏⢦⣹⣷⡟⣛⢻⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⣼⡿⠊⣹⠴⡩⣍⡓⢾⢹⣷⣶⣿⣿⣿⣿⣿⣿⢣⣿⣯⣿⠟⢸⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⢯⡟⡬⠲⣼⡷⡘⢦⢓⡚⢦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠋⣠⢚⣼⣷⡱⢆⡹⢺⠈⢿⣿⣿⣿⣿⣿⣿⠏⣸⣿⠟⠁⠀⠈⢿⣿⣿⣿⣿⣿⣿⣿⡿⣻⣿⡟⡜⢲⡙⣼⢲⡙⢆⡫⢜⠲⣌⣫⠟⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⢀⢴⡛⢬⠲⡌⢿⣿⣮⣕⣫⡆⠈⠛⠻⠿⠛⠛⠁⠀⠛⠁⠀⠀⠀⠀⠈⠛⠿⣿⣿⡿⢿⢫⡗⡥⡿⠜⣜⢣⣱⡟⢦⡙⣬⣱⣮⠗⠋⠄⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠛⠲⠛⠦⠯⣼⣉⢿⣟⣿⣻⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⢧⢱⠩⢞⣰⣷⡟⡱⡗⠛⠋⠁⠀⠀⠀⠀⠘⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠰⠠⢀⠀⢢⡇⡎⣽⣿⡽⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠄⠀⠀⠀⠀⠀⢀⠈⠠⣿⣷⡿⣿⢿⣿⢏⠼⣡⢻⡀⠀⢄⠀⠀⠀⠀⡁⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⣠⠈⠐⠈⣷⣱⣏⠿⣷⣿⡆⠀⠀⠀⠀⠀⠀⠂⠐⠀⠒⠈⠀⠀⠀⠀⠀⠠⠊⢀⢰⣿⣯⡷⣟⣾⠋⠺⣴⣩⢚⡇⠂⢈⠀⠀⠀⠀⢡⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⢀⠀⠀⠀⠘⣄⠀⠀⠈⢱⣎⢳⡹⢿⣿⡷⢤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠐⣀⣿⣿⣳⡿⠫⢎⡀⠀⠀⠙⠮⡟⠀⢈⠀⠠⢀⠂⠄⣸⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀",
        "⠀⢸⠁⢄⠀⠀⠘⢆⠀⠂⠈⣎⢧⡙⢾⡛⠛⠉⢀⢩⠒⠦⠤⣤⣀⣀⣀⣀⣀⣮⢤⣾⠖⡛⢩⣿⠗⡋⠤⠂⠂⣈⠽⠀⠀⠀⠀⢀⠀⣀⡴⣇⠰⣆⠇⠀⠀⢀⠎⢸⠀⠀⠀⠀⠀",
        "⠀⠈⡆⡀⠑⠠⡀⠈⠳⣄⠀⠘⡶⣙⢦⡛⢶⢄⡀⠀⠀⡩⠁⠸⣷⣤⣄⣀⣤⣶⠾⡉⢠⠤⠟⠁⠀⣠⠴⣮⡁⠀⠀⠀⠀⠐⢈⣠⠼⣱⠳⣜⢫⠎⠀⢀⠔⠁⠀⠘⡀⠀⠀⠀⠀",
        "⠀⠀⢡⠀⠀⠀⠈⡑⠤⢀⣉⡒⠽⠼⣦⠝⣑⡐⡟⠀⢈⡉⠀⢇⢼⣿⣿⣿⣿⡿⠀⠐⠆⠀⡀⠀⠈⡆⡄⢀⠛⢓⣤⡦⢵⠺⣍⢎⡳⢥⡛⣬⠋⡠⠖⠑⠀⠀⠀⢠⠁⠀⠀⠀⠀",
        "⠀⠀⠀⢇⠂⠀⠀⠐⠀⠀⠀⢀⡴⢋⡠⡑⠄⢊⢗⠊⣥⣧⣴⠶⣾⣟⣿⣻⢿⣧⡒⡄⡜⢥⡉⣗⠲⣼⠜⠁⢀⠎⠸⣝⡻⣵⡎⢮⣱⡧⣛⠕⠈⠀⠀⠘⠀⠀⡠⢺⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠈⢦⡙⡖⣦⢤⣤⠞⣉⠔⣢⠱⣉⢎⢂⠁⣷⡘⡗⢩⢉⢸⣿⣾⣯⣿⣿⠘⡊⠍⠦⢱⣸⣗⢀⢰⠐⡡⢊⡀⠈⡑⢧⣛⢯⣐⠈⠀⠀⠀⠠⠐⠈⣨⠞⡧⡚⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠉⠚⣶⡋⢄⠲⣡⠚⡤⢓⡌⣎⣞⣳⡼⣩⡗⠢⠌⣻⣿⣳⢿⣽⣻⠀⠁⢀⠂⠄⣗⢮⡟⡥⡘⣌⢣⡙⢆⠠⢀⠙⢮⡝⣳⢦⣄⠀⢀⣤⠻⣥⠻⡱⠁⠀⠀⠀⠀⠀",
        "⢰⠄⡀⠀⠀⠀⡊⠁⠙⢮⡓⢤⢋⡔⣣⢞⡵⣮⢟⣲⡵⣁⣉⢉⣿⣿⣻⣿⣻⣿⡁⠔⠁⡈⢰⣏⢾⡯⣝⣧⡘⢆⡱⢊⡍⢦⡐⢀⠘⢣⡏⣾⢳⣻⣬⠳⠊⠔⠀⠀⢀⠀⠤⠐⠰",
        "⠈⡆⠀⠁⠂⢸⠙⣤⠁⠠⠙⢮⣲⣜⢷⣫⢾⡙⣮⠏⣔⣶⣾⣴⣿⣿⣿⡾⣿⣿⡈⠉⠉⠉⢉⣉⣉⡷⣩⢏⣷⡊⡔⢣⠜⣢⢑⠣⢆⣠⠞⢫⡳⣜⣺⠒⠄⠀⠀⠉⠀⠀⠀⢀⠆",
        "⠀⢡⠀⡀⠀⠀⠣⣈⠲⣁⠰⣜⡳⣯⡾⢣⢇⣿⢏⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣴⣭⣵⣭⣹⣏⡞⣧⣓⢎⡖⣻⣌⢣⠚⡤⢋⡼⠚⠁⡀⠂⢙⡼⠁⢀⠀⢀⠃⠀⠀⠀⠀⡌⠀",
        "⠀⠀⢃⠀⣄⠀⠀⠠⠑⠚⠛⣶⡹⢯⡱⣋⢾⣿⣞⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡹⣝⣷⠮⣜⡱⢻⣆⡹⣰⠏⡰⢶⠁⢠⡵⠫⠁⢀⠌⡠⠁⠀⠀⠀⠀⡜⠀⠀",
        "⠀⠀⠈⠣⣀⠊⢄⣀⡬⣟⡹⢆⣛⢦⣳⣿⣿⣷⣯⣭⣷⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⢻⡜⡾⣿⡰⣍⠳⣎⠿⣅⡸⠟⢀⡴⠯⠴⠤⠔⠁⠀⠀⠁⡘⠀⢐⠜⠀⠀⠀",
        "⠀⠀⠀⠀⠈⠑⠪⠌⣒⠣⢝⣾⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠹⣿⣿⣿⣿⢿⠿⣏⣷⣹⣳⠽⡗⣎⢳⢬⠳⣭⡝⠛⠋⠀⠀⠀⠀⠀⠀⠠⣐⢤⠔⡤⠊⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠋⣤⣾⣿⣿⣿⣟⢿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⢿⣿⣿⣿⣾⣶⣿⠿⡻⣿⣶⣣⡝⢮⡜⢦⣍⢳⡒⠶⡒⠖⣀⣀⡤⢖⣲⠫⢊⠔⠁⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣝⣿⣟⣿⣿⣧⣙⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⡟⣡⣷⣿⠿⣷⣿⣿⣦⡝⡲⢬⢣⡝⣣⢝⡹⢆⡳⡼⢓⡨⠒⠁⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⢹⣾⡏⢭⡙⢿⣿⣿⣮⢟⣿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣏⣼⣿⣿⣧⣇⣿⣿⣿⣹⣿⣟⠺⠥⣎⣑⣈⣣⠭⠔⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣷⣢⣞⢯⣿⣿⣟⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣳⡟⢦⡹⢯⡘⢼⣫⡝⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠻⠿⠟⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣇⠣⡜⢢⢷⡹⣎⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⡒⡍⢆⣯⢳⣭⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⠿⣿⣷⣮⣾⠿⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀",
        "*/",
        "//array <class T, size_t N> arr;",
        "//vector <class T, class Alloc = allocator<T>> vector;",
        "//deque <class T, class Alloc = allocator<T> > deque;",
        "//priority_queue <class T, class Container = vector<T>,class Compare = less<typename Container::value_type>> priority_queue;",
        "//queue <class T, class Container = deque<T>> queue;",
        "//map <class Key, class T, class Compare = less<Key>, class Alloc = allocator<pair<const Key,T>>> map;",
        "#define FOR(i,a,b)      \tfor(int64_t i=a;i<=b;i++)",
        "#define fr(i,n)         \tfor(int64_t i=0;i<n;i++)",
        "#define fr1(i,n)        \tfor(int64_t i=1;i<=n;i++)",
        "#define FORI(i,a,b)      \tfor(int32_t i=a;i<=b;i++)",
        "#define fri(i,n)         \tfor(int32_t i=0;i<n;i++)",
        "#define fr1i(i,n)        \tfor(int32_t i=1;i<=n;i++)",
        "#define FORD(i, a, b)  \t\tfor(int64_t i=a;i>=b;i--)",
        "#define FORDI(i, a, b)\t\tfor(int32_t i=a;i>=b;i--)",
        "#define forv(a, b)\t\t\tfor(auto &a : b)",
        "#define sortall(arr)   \t \tsort(arr.begin(), arr.end())",
        "#define sortallmax(arr)\t \tsort(arr.begin(), arr.end(), greater<int64_t>())",
        "#define elif\t\t\t\telse if",
        "#define pb\t\t\t\t\tpush_back",
        "#define pf\t\t\t\t\tpush_front",
        "#define mp\t\t\t\t\tmake_pair",
        "#define fi\t\t\t\t\tfirst",
        "#define se\t\t\t\t\tsecond",
        "#define th\t\t\t\t\tthird",
        "#define str\t\t\t\t\tstring",
        "#define int\t\t\t\t\tlong long ",
        "#define endline\t\t\t\t\"\\n\"",
        "#define spaceuk\t\t\t\t\" \"",
        "#define driver\t\t\t\tint32_t",
        "#define vi\t\t\t\t\tvector<int32_t>",
        "#define qi\t\t\t\t\tqueue<int32_t>",
        "#define reset(a,b)\t\t\tmemset(a,b,sizeof(a))",
        "#define TOINFINITYANDBEYOND\t0x3f3f3f3f",
        "#define PI\t\t\t\t\t3.1415926535897932384626433832795",
        "const long long MODULO =\t1e9+7;",
        "const double pi =\t\t\tacos(-1.0);",
        "auto start =\t\t\t\tchrono::steady_clock::now();",
        "void finish(){",
        "\tauto end = chrono::steady_clock::now();",
        "\t//cout << \"Code run time: \";",
        "\tcout << chrono::duration<double, std::milli>(end - start).count() << \"ms\" << endl;",
        "\tfclose(stdin);",
        "\tfclose(stdout);",
        "\treturn;",
        "}",
        "#define ultimate_matrix",
        "/************************* Matrix **************************/",
        "// FOR NORMAL PEOPLE:",
        "#ifndef ultimate_matrix",
        "const int64_t length = 2;",
        "struct matrix{",
        "\tint64_t m[length][length];",
        "};",
        "matrix operator *(matrix a, matrix b)",
        "{",
        "\tmatrix c;",
        "\tfr(i,length) fr(j,length){",
        "\t\tc.m[i][j] = 0;",
        "\t\tfr(t,length) c.m[i][j] = (c.m[i][j] + (a.m[i][t] * b.m[t][j]) % MODULO) % MODULO;",
        "\t}",
        "\treturn c;",
        "}",
        "matrix operator ^(matrix a, int64_t n)",
        "{",
        "\tif (n == 1) return a;",
        "\tmatrix temp = a ^ (n / 2);",
        "\ttemp = temp * temp;",
        "\tif (n % 2 == 0) return temp;",
        "\telse return (temp * a);",
        "}",
        "/***********************************************************/",
        "#else",
        "/******************** ULTIMATE Matrix **********************/",
        "template<int32_t _MODULO> struct Modular{",
        "\tint64_t v;",
        "\texplicit operator int32_t() const {return v;} //explicitly -> don't silently convert to int32_t",
        "\tModular() {v = 0;}",
        "\tModular(int64_t _v) ",
        "\t{",
        "\t\tv = int32_t((-_MODULO < _v && _v < _MODULO) ? _v : _v % _MODULO); ",
        "\t\tif (v < 0) v += _MODULO;",
        "\t}",
        "\tfriend ostream& operator << (ostream& out, const Modular &n)",
        "\t{",
        "\t\treturn out << int32_t(n);",
        "\t}",
        "\tfriend istream& operator >> (istream& in, const Modular &n)",
        "\t{",
        "\t\tint64_t _v;",
        "\t\tin >> _v;",
        "\t\tn = Modular(_v);",
        "\t\treturn in;",
        "\t}",
        "",
        "\tfriend bool operator == (const Modular &a, const Modular &b) {return a.v == b.v;}",
        "\tfriend bool operator != (const Modular &a, const Modular &b) {return a.v != b.v;}",
        "\tfriend bool operator < (const Modular &a, const Modular &b) {return a.v < b.v;}",
        "\tfriend bool operator > (const Modular &a, const Modular &b) {return a.v > b.v;}",
        "\t",
        "\tModular& operator += (const Modular &m)",
        "\t{",
        "\t\tif ((v += m.v) > _MODULO)",
        "\t\t\tv -= _MODULO;",
        "\t\treturn *this;",
        "\t}",
        "\tModular& operator -= (const Modular &m)",
        "\t{",
        "\t\tif ((v -= m.v) < 0)",
        "\t\t\tv += _MODULO;",
        "\t\treturn *this;",
        "\t}",
        "\tModular& operator *= (const Modular &m)",
        "\t{",
        "\t\tv = int32_t((int64_t) v * m.v % _MODULO);",
        "\t\treturn *this;",
        "\t}",
        "\tModular& operator /= (const Modular &m)",
        "\t{",
        "\t\treturn (*this) *= inv(m);",
        "\t}",
        "\tModular operator - () const {return Modular(-v);}",
        "",
        "\tModular &operator ++() {return *this += 1;}",
        "\tModular &operator --() {return *this -= 1;}",
        "\tfriend Modular pow(Modular a, int64_t p)",
        "\t{",
        "\t\tModular ans = 1;",
        "\t\tassert(p >= 0);",
        "\t\tfor(; p; p /= 2, a *= a)",
        "\t\t\tif (p & 1)",
        "\t\t\t\tans *= a;",
        "\t\treturn ans;",
        "\t}",
        "\tfriend Modular inv(const Modular &a)",
        "\t{",
        "\t\tassert(a.v != 0);",
        "\t\treturn pow(a, _MODULO - 2);",
        "\t}",
        "\tfriend Modular operator + (Modular a, const Modular &b) {return a += b;}",
        "\tfriend Modular operator - (Modular a, const Modular &b) {return a -= b;}",
        "\tfriend Modular operator * (Modular a, const Modular &b) {return a *= b;}",
        "\tfriend Modular operator / (Modular a, const Modular &b) {return a /= b;}",
        "\tfriend Modular operator ++ (Modular &a, int32_t)",
        "\t{",
        "\t\tModular r = a;",
        "\t\t++ a;",
        "\t\treturn r;",
        "\t}",
        "\tfriend Modular operator -- (Modular &a, int32_t)",
        "\t{",
        "\t\tModular r = a;",
        "\t\t-- a;",
        "\t\treturn r;",
        "\t}",
        "};",
        "",
        "template <class T> struct matrix{",
        "\tvector<vector<T>> m;",
        "\tint64_t r, c;",
        "\tmatrix() : r(), c() {}",
        "\tmatrix(int64_t r, int64_t c, T x) : r(r), c(c), m(r, vector<T> (c, x)) {}",
        "\tmatrix(int64_t n) : matrix (n, n, 0) \t//identity matrix",
        "\t{",
        "\t\tfor(int64_t i = 0; i < n; i ++)",
        "\t\t\tm[i][i] = 1;",
        "\t}",
        "\tmatrix operator * (matrix<T> b)",
        "\t{",
        "\t\tmatrix<T> a = *this;",
        "\t\tassert(a.c == b.r);",
        "\t\tmatrix<T> c(a.r, b.c, 0);",
        "\t\t{",
        "\t\t\tfor(int64_t i = 0; i < a.r; i ++)",
        "\t\t\t\tfor(int64_t j = 0; j < b.c; j ++)",
        "\t\t\t\t\tfor(int64_t k = 0; k < a.c; k ++)",
        "\t\t\t\t\t\tc.m[i][j] = c.m[i][j] + a.m[i][k] * b.m[k][j];",
        "\t\t}",
        "\t\treturn c;",
        "\t}",
        "\tmatrix operator ^ (int64_t b)",
        "\t{",
        "\t\tmatrix<T> a = *this;",
        "\t\tassert(a.r == a.c);",
        "\t\tmatrix<T> o(a.r);",
        "\t\twhile(b)",
        "\t\t{",
        "\t\t\tif (b % 2)",
        "\t\t\t\to = o * a;",
        "\t\t\ta = a * a;",
        "\t\t\tb /= 2;",
        "\t\t}",
        "\t\treturn o;",
        "\t}",
        "\tvoid print()",
        "\t{",
        "\t\tfor(int64_t i = 0; i < r; i ++)",
        "\t\t{",
        "\t\t\tfor(int64_t j = 0; j < c; j ++)",
        "\t\t\t\tcout << m[i][j] << spaceuk;",
        "\t\t\tcout << endline;",
        "\t\t}",
        "",
        "\t}",
        "};",
        "",
        "using mint = Modular<MODULO>;",
        "#endif",
        "/***********************************************************/",
        "//predefined functions:",
        "template<typename A, typename B, typename C>\tstruct threesome{",
        "\tA first;",
        "\tB second;",
        "\tC third;",
        "};",
        "int64_t getbit(int32_t i, int64_t x){return ((x >> i) & 1);}",
        "int64_t mul(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 0;",
        "\twhile (b > 0)",
        "\t{",
        "\t\tif (b % 2 == 1)",
        "\t\t\tres = (res + a);",
        "\t\ta = (a * 2);",
        "\t\tb /= 2;",
        "\t}",
        "\treturn res;",
        "}",
        "int64_t power(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 1;",
        "\ta %= b;",
        "\tif (a == 0) return 0;",
        "\twhile(b > 0)",
        "\t{",
        "\t\tif (b & 1)",
        "\t\t\tres = mul(res, a);",
        "\t\tb /= 2;",
        "\t\ta = mul(a, a);",
        "\t}",
        "\treturn res;",
        "}",
        "int64_t Modular_multiplication(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 0;",
        "\ta %= MODULO;",
        "\twhile (b > 0)",
        "\t{",
        "\t\tif (b % 2 == 1)",
        "\t\t\tres = (res + a) % MODULO;",
        "\t\ta = (a * 2) % MODULO;",
        "\t\tb /= 2;",
        "\t}",
        "\treturn res % MODULO;",
        "}",
        "int64_t Modular_exponentiation(int64_t a, int64_t b)",
        "{",
        "\tint64_t res = 1;",
        "\ta %= b;",
        "\tif (a == 0) return 0;",
        "\twhile(b > 0)",
        "\t{",
        "\t\tif (b & 1)",
        "\t\t\tres = Modular_multiplication(res, a);",
        "\t\tb /= 2;",
        "\t\ta = Modular_multiplication(a, a);",
        "\t}",
        "\treturn res;",
        "}",
        "/***********************************************************/",
        "//Global variables below this line:",
        "",
        "/***********************************************************/",
        "//Functions declarations:",
        "",
        "/***********************************************************/",
        "// #define task \"\"",
        "// #define standard_input ",
        "#define input_extension \".inp\"",
        "#define output_extension \".out\"",
        "driver main(){",
        "\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
        "#ifndef standard_input",
        "\t#ifdef task",
        "\t\tif (!fopen(task input_extension,\"r\"))",
        "\t\t\treturn -1;",
        "\t\tfreopen (task input_extension, \"r\", stdin);",
        "\t\tfreopen (task output_extension, \"w\", stdout);",
        "\t#else",
        "\t\tif (!fopen(\"input.inp\",\"r\"))",
        "\t\t{",
        "\t\t\tcerr << \"U STUPID\" << endline;",
        "\t\t\treturn -1;",
        "\t\t}",
        "\t\tfreopen (\"input.inp\",\"r\",stdin);",
        "\t\tfreopen (\"output.out\",\"w\",stdout);",
        "\t#endif",
        "#endif",
        "\t//code below this line:",
        "\t",
        "#ifndef standard_input",
        "\t#ifndef task",
        "\t\tfinish();",
        "\t#endif",
        "#endif",
        "\treturn 0;",
        "}",
        "//Functions content:",
        "\t"